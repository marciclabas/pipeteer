{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to Pipeteer","text":"<p>Pipeteer simplifies the complexity of durable execution whilst not hiding the underlying persistence.</p>"},{"location":"#why-pipeteer","title":"Why Pipeteer?","text":"<p>Use <code>pipeteer</code> if you need...</p> <ul> <li>Persistance: your app can stop or crash and resume at any time without losing progress</li> <li>Observability: you can see the state of your app at any time, and modify it programmatically at runtime</li> <li>Exactly-once semantics: your app can be stopped and resumed without dropping or duplicating work</li> <li>Fault tolerance: if a task fails, it'll keep working on other tasks and retry it later</li> <li>Explicit data: <code>pipeteer</code>'s high level API is a very thin abstraction over explicit communication using queues</li> </ul>"},{"location":"#proof-of-concept","title":"Proof of Concept","text":"<pre><code>from pipeteer import activity, workflow, Context, WorkflowContext\n\n@activity()\nasync def double(x: int) -&gt; int:\n  return 2*x\n\n@activity()\nasync def inc(x: int) -&gt; int:\n  return x + 1\n\n@workflow([double, inc])\nasync def linear(x: int, ctx: WorkflowContext) -&gt; int:\n  x2 = await ctx.call(double, x)\n  return await ctx.call(inc, x2)\n\nif __name__ == '__main__':\n  ctx = Context.sqlite('workflow.db')\n  linear.run_all(ctx)\n</code></pre> <p>Let's see how it all works under the hood, using queues</p>"},{"location":"pipelines/","title":"Pipelines","text":"<p>Pipelines are units of computation. Every pipeline:</p> <ul> <li>Has an input (read) and an output (write) queue.</li> <li>Can be composed into larger pipelines.</li> </ul>"},{"location":"pipelines/#pipeline-abc","title":"Pipeline ABC","text":"<p>The pipeline interface is roughly defined as:</p> <pre><code>from multiprocessing import Process\nfrom pipeteer import ReadQueue, WriteQueue\n\nclass Pipeline(Generic[A, B]):\n  async def run(self, Qin: ReadQueue[A], Qout: WriteQueue[B]):\n    ...\n</code></pre> <p>Composition in <code>pipeteer</code> works by connecting the output of one pipeline to the input of another, creating arbitrary graphs.</p> <p>Let's see a few concrete pipelines.</p>"},{"location":"pipelines/#activity","title":"Activity","text":"<p>Activities perform a 1-to-1 transformation. You'll generally define them using the <code>@activity</code> decorator.</p> <pre><code>from pipeteer import activity\n\n@activity()\nasync def double(x: int) -&gt; int:\n  return 2*x\n</code></pre> <p>But don't be fooled! This is roughly equivalent to:</p> <pre><code>from timedelta import timedelta\nfrom pipeteer import Pipeline\n\nclass Double(Pipeline[int, int]):\n  async def run(self, Qin: ReadQueue[A], Qout: WriteQueue[B]):\n    while True:\n      key, x = await Qin.wait_any(reserve=timedelta(minutes=2))\n      await Qout.push(key, 2*x)\n      await Qin.pop(key)\n</code></pre>"},{"location":"pipelines/#task","title":"Task","text":"<p>Tasks are a bit more general, giving you explicit control over the underlying queues. A common use case is for external APIs and human intervention:</p> <pre><code>from multiprocessing import Process\nfrom fastapi import FastAPI\nfrom pipeteer import task, ReadQueue, WriteQueue\n\n@task\ndef manual_review(Qin: ReadQueue[str], Qout: WriteQueue[bool]):\n  app = FastAPI()\n\n  @app.get('/tasks')\n  async def get_tasks() -&gt; list[tuple[str, str]]:\n    return [t async for t in Qin.items()]\n\n  @app.post('/tasks/{key}')\n  async def review(key: str, approve: bool):\n    await Qout.push(key, approve)\n    await Qin.pop(key)\n\n  return app\n</code></pre>"},{"location":"pipelines/#workflow","title":"Workflow","text":"<p>Workflows are pipelines that can perform arbitrary transformations. You'll generally define them using the <code>@workflow</code> decorator.</p> <pre><code>from pipeteer import workflow, WorkflowContext\n\n@workflow([double])\nasync def quad(x: int, ctx: WorkflowContext) -&gt; int:\n  x2 = await ctx.call(double, x)\n  return await ctx.call(double, x2)\n</code></pre> <p>But again, this maps out to a <code>Qin</code> + <code>Qout</code> function! It's a bit more complex this time around, but the idea is the same:</p> <p><code>workflow</code> is just a fancy way to compose pipelines: you could achieve the same by connecting queues manually.</p>"},{"location":"pipelines/#a-note-on-durable-execution","title":"A note on durable execution","text":"<p>Workflow is an example of the \"durable execution\" concept. This is how it works:</p> <ol> <li>You call <code>ctx.call(double, x)</code></li> <li>Under the hood, <code>pipeteer</code> pushes <code>x</code> to <code>double</code>'s input queue, and stops the execution.</li> <li>When the result is received, <code>pipeteer</code> will re-run <code>quad</code>. When you <code>ctx.call</code>, it will immediately return the previously computed result.</li> </ol> <p>This happens at every <code>ctx.call</code>: the function is re-run using the cached results.</p> <p>You may have noticed that we <code>Qout.push</code>ed and then <code>Qin.pop</code>ed: but what if the second fails!? That's were transactions come in.</p>"},{"location":"queues/","title":"Queues","text":"<p>Queues are how <code>pipeteer</code>'s pipelines communicate. A <code>Queue[T]</code> is an transactional, async key-value store.</p>"},{"location":"queues/#operations","title":"Operations","text":"<p>Queues support the following operations:</p> <ul> <li><code>async def push(key: str, value: T)</code></li> <li><code>async def pop(key: str) -&gt; T</code></li> <li><code>async def read(key: str) -&gt; T</code></li> <li><code>async def read_any() -&gt; tuple[str, T]</code></li> <li><code>def items() -&gt; AsyncIterable[tuple[str, T]]</code></li> <li>(and a few more)</li> </ul>"},{"location":"queues/#views","title":"Views","text":"<p>Queues can have two separate views:</p> <ul> <li><code>ReadQueue[T]</code>: can be read and popped from, but not pushed to.</li> <li><code>WriteQueue[T]</code>: can be pushed to, but not read or popped from.</li> </ul> <p>In general, <code>Queue</code>s are stored somewhere in disk or memory, whilst views may be transformations of the underlying <code>Queue</code>.</p> <p>Let's see how these are used by pipelines!</p>"},{"location":"transactions/","title":"Transactions","text":"<p>Queues have a transactional interface, though the semantics may vary depending on the implementation. Using the default SQL-backed queues, transactions are ACID-compliant.</p> <p>You can define transactions this way:</p> <pre><code>from pipeteer import Transaction\n\nasync with Transaction(Qin, Qout) as tx:\n  await Qout.push('key', 'value')\n  await Qin.pop('key')\n  await tx.commit()\n</code></pre> <p>You can add as many queues as you want to the transaction, and also autocommit it:</p> <pre><code>async with Transaction(Q1, Q2, Q2, autocommit=True):\n  ...\n</code></pre>"}]}