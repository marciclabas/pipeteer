{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to Pipeteer","text":"<p>Pipeteer simplifies the complexity of durable execution whilst not hiding the underlying persistence.</p>"},{"location":"#why-pipeteer","title":"Why Pipeteer?","text":"<p>Use <code>pipeteer</code> if you need...</p> <ul> <li>Persistance: your app can stop or crash and resume at any time without losing progress</li> <li>Observability: you can see the state of your app at any time, and modify it programmatically at runtime</li> <li>Exactly-once semantics: your app can be stopped and resumed without dropping or duplicating work</li> <li>Fault tolerance: if a task fails, it'll keep working on other tasks and retry it later</li> <li>Explicitness: <code>pipeteer</code>'s high level API is a very thin abstraction over SQLModel (for persistance) and ZeroMQ (for inter-process communication)</li> </ul>"},{"location":"#proof-of-concept","title":"Proof of Concept","text":"<p>Definition. You can define a durable workflow this easy:</p> <pre><code>from pipeteer import activity, workflow, WorkflowContext\n\n@activity()\nasync def double(x: int) -&gt; int:\n  return 2*x\n\n@workflow()\nasync def quad(x: int, ctx: WorkflowContext) -&gt; int:\n  x2 = await ctx.call(double, x)\n  x4 = await ctx.call(double, x2)\n  return x4\n</code></pre> <p>Worker. And here's how to run it:</p> <pre><code>import asyncio\nfrom pipeteer import DB, Context\n\ndb = DB.at('pipeline.db')\nctx = Context.of(db)\n\nasync def main():\n  await asyncio.gather(\n    double.run(ctx),\n    quad.run(ctx),\n    ctx.zmq.proxy(),\n  )\n</code></pre> <p>Input. How to give it tasks?</p> <pre><code>from pipeteer import DB, Context\n\ndb = DB.at('pipeline.db')\nctx = Context.of(db)\n\nInput = quad.input(ctx)\nwith db.session as s:\n  s.add(Input(key='task', value=1, output='my-output'))\n  s.commit()\n\nawait quad.notify(ctx)\n</code></pre> <p>Output. How to get the results?</p> <pre><code>from sqlmodel import select\nfrom pipeteer import DB, Context\n\ndb = DB.at('pipeline.db')\nctx = Context.of(db)\n\nOutput = quad.output(ctx, 'my-output')\nwhile True:\n  with db.session as s:\n    for entry in s.exec(select(Output)):\n      print(f'Output: {entry.key} -&gt; {entry.value}')\n      s.delete(entry)\n    s.commit()\n  await ctx.wait('my-output')\n</code></pre>"},{"location":"activity/","title":"Activity","text":"<p>An <code>activity</code> is the simplest pipeline, a 1-to-1 transformation. It can perform side-effects also.</p> <pre><code>from pipeteer import activity\n\n@activity()\nasync def double(x: int) -&gt; int:\n  return 2*x\n</code></pre>"},{"location":"activity/#context","title":"Context","text":"<p>Your activity may want to access some external service, or receive some configuration:</p> <pre><code>from dataclasses import dataclass\nfrom mylib import MyClient\nfrom pipeteer import activity, Context\n\n@dataclass\nclass MyContext(Context):\n  client: MyClient\n\n@activity()\nasync def fetch_age(username: str, ctx: MyContext) -&gt; int:\n  user = await ctx.client.get_user(username)\n  return user.age\n</code></pre> <p>To run it, you need to provide your context instead of the default one:</p> <pre><code>from pipeteer import DB\n\ndb = DB.at('pipe.db')\nctx = MyContext(db, client=MyClient())\n\nfetch_age.run(ctx)\n</code></pre>"},{"location":"task/","title":"Task","text":"<p>A <code>task</code> is the go-to way to define a completely arbitrary pipeline. You've got access to the underlying table with the tasks.</p> <p>The most common use case is to expose an API for users to manipulate tasks:</p>"},{"location":"task/#example-manual-approval","title":"Example: Manual Approval","text":"<pre><code>from fastapi import FastAPI\nfrom sqlmodel import select\nfrom pipeteer import task, workflow, InputT, Push, Context, WorkflowContext\n\n@task()\nasync def approve(Inp: InputT[str], push: Push[bool], ctx: Context):\n\n  app = FastAPI()\n\n  @app.get('/tasks')\n  def get_tasks() -&gt; list[tuple[str, str]]:\n    with ctx.db.session as s:\n      tasks = s.exec(select(Inp)).all()\n      return [(task.key, task.value) for task in tasks]\n\n  @app.get('/approve/{key}')\n  async def approve(key: str):\n    await push(key, True)\n\n  @app.get('/reject/{key}')\n  async def reject(key: str):\n    await push(key, False)\n\n  return app\n\n@workflow()\nasync def wkf(task: str, ctx: WorkflowContext) -&gt; bool:\n  ok = await ctx.call(approve, task)\n  return ok\n</code></pre>"},{"location":"task/#running","title":"Running","text":"<p>How to run it? Completely up to you. For instance:</p> <pre><code>import asyncio\nfrom multiprocessing import Process\nimport uvicorn\nfrom pipeteer import DB, Context\n\ndb = DB.at('pipe.db')\nctx = Context.of(db)\n\nprocs = [\n  Process(target=uvicorn.run, args=[approve,run(ctx)]),\n  Process(target=asyncio.run, args=[wkf.run(ctx)]),\n]\nfor proc in procs:\n  proc.start()\nfor proc in procs:\n  proc.join()\n</code></pre>"},{"location":"workflow/","title":"Workflow","text":"<p>A <code>workflow</code> is the go-to way to compose pipelines in code.</p>"},{"location":"workflow/#purity","title":"Purity","text":"<p>It's very important that your workflow function is pure. The function will be run many times: think of it as a way to describe the pipeline, not to run it.</p> <p>But don't worry. If it's not pure, <code>pipeteer</code> will complain (at runtime).</p>"},{"location":"workflow/#example","title":"Example","text":"<pre><code>import random\nfrom pipeteer import workflow, activity, WorkflowContext\n\n@activity()\nasync def impure_activity(p: float) -&gt; bool:\n  return random.random() &lt; p\n\n@workflow()\nasync def greet(name: str, ctx: WorkflowContext) -&gt; str:\n  hello = await ctx.call(impure_activity, 0.5)\n  if hello:\n    return f'Hello, {name}!'\n  else:\n    return f'Goodbye, {name}!'\n</code></pre> <p>Note that, assuming <code>ctx.call</code> returns the same result, then <code>greet</code> is pure.</p> <p>That's what allows us to restart the pipeline after an outage, or a week later, and go on as if nothing had happened.</p>"}]}